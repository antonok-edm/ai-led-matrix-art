/* -- USER INPUTS -- */

// Provide an API key
const OPENAI_SECRET_KEY = 'sk-...';
// The generated patterns should look like...
const userGoal = 'flowers blossoming in a psychedelic field';

/* -- PROMPTS -- */

// Language documentation appended to prompts where code output is expected.
// Note: this was generated by feeding the language documentation directly to GPT-4 and asking to condense it several times.
// Small manual tweaks were then made to remove out-of-scope features (like the accelerometer) and to emphasize common mistakes.
const languageFeaturesAppendix = `
### Supported Language Features

- **Math Operators**: Pixelblaze supports all usual math operators (\`=\`, \`+\`, \`-\`, \`!\`, \`*\`, \`/\`, \`%\`, \`>>\`, \`<<\`, \`|\`, \`&\`, \`~\`, \`^\`, \`>\`, \`<\`, \`>=\`, \`<=\`, \`==\`, \`!=\`, \`||\`, \`&&\`, \`?\`). These work on 16.16 fixed-point math, with most bitwise operators working on all 32 bits. The \`~\` operator zeroes out the lower 16 bits.
    
- **Logical Operators**: Function like JavaScript, returning values instead of booleans. Example: \`v = 0 || 42\` results in 42.
    
- **Math Functions**:
    
    - \`abs(v)\`: Absolute value. Returns \`2\` for \`abs(-2)\`.
    - \`acos(x)\`: Arccosine in radians.
    - \`asin(x)\`: Arcsine in radians.
    - \`atan(x)\`: Arctangent in radians.
    - \`atan2(y, x)\`: Angle in radians between the positive x-axis and the point \`(x, y)\`.
    - \`ceil(v)\`: Rounds up to the next largest integer.
    - \`clamp(value, low, hi)\`: Clamps \`value\` between \`low\` and \`hi\`.
    - \`cos(angleRads)\`: Cosine of the angle in radians.
    - \`exp(x)\`: Euler's number raised to the power of \`x\`.
    - \`floor(v)\`: Rounds down to the next smallest integer.
    - \`frac(v)\`: Fractional component of \`v\`.
    - \`hypot(x, y)\`: Square root of the sum of squares of \`x\` and \`y\`.
    - \`hypot3(x, y, z)\`: Square root of the sum of squares of \`x\`, \`y\`, and \`z\`.
    - \`log(v)\`: Natural logarithm (base e).
    - \`log2(v)\`: Base 2 logarithm.
    - \`max(v1, v2)\`: Larger of two numbers.
    - \`min(v1, v2)\`: Smaller of two numbers.
    - \`mod(x, y)\`: Floored remainder of \`x/y\`.
    - \`pow(base, exponent)\`: \`base\` to the \`exponent\` power.
    - \`random(max)\`: Random number between 0.0 and \`max\`.
    - \`prng(max)\`: Pseudorandom number generator.
    - \`prngSeed(seed)\`: Set a seed for \`prng()\`.
    - \`round(v)\`: Rounds a number to the nearest integer.
    - \`sin(angleRads)\`: Sine of an angle in radians.
    - \`sqrt(v)\`: Square root of \`v\`.
    - \`tan(angleRads)\`: Tangent of an angle in radians.
    - \`trunc(v)\`: Integer component of \`v\`.

YOU DO NOT NEED Math.pow() just pow(). it's different than Javascript.

- **Variable Declaration**: Using \`var\` or implicit global declaration. Example: \`var foo = 1\`.
    
- **Conditionals**: \`if\` and \`else\`.
    
- **Loops**: \`while\` and \`for\` loops, with \`break\` and \`continue\`.
    
- **Function Definition**: Using \`function\` keyword or lambda-style. Can be stored in variables, passed as arguments, or returned from other functions.
    
- **Arrays**: Created with \`array(size)\` function or array literals. Accessible with bracket syntax and passable like any other type.
    

### Language Limitations

- Lacks objects, named properties, classes, garbage collection, closures, \`switch\` + \`case\` statements. Uses chained \`else if\` or functions in an array for similar functionality.

### Variables

- \`pixelCount\`: Global variable available during initialization, indicating the number of LED pixels configured.

### Constants

- Mathematical constants: \`E\`, \`PI\`, \`PI2\`, \`PI3_4\`, \`PISQ\`, \`LN2\`, \`LN10\`, \`LOG2E\`, \`LOG10E\`, \`SQRT1_2\`, \`SQRT2\`.

### Array Functions

- **array(n)**: Creates an array with \`n\` elements.
- **arrayForEach(a, fn)**: Iterates over array \`a\`, executing \`fn(value, index, array)\` for each element.
- **arrayLength(a)**: Returns the size of array \`a\`.
- **arrayMapTo(src, dest, fn)**: Maps each element of \`src\` array to \`dest\` array using \`fn(value, index, array)\`. Discards excess if \`dest\` is smaller.
- **arrayMutate(a, fn)**: Modifies array \`a\` in place using \`fn(value, index, array)\`.
- **arrayReduce(a, fn, initialValue)**: Reduces array \`a\` to a single value using \`fn(accumulator, value, index, array)\`, starting with \`initialValue\`.
    - Example: \`arrayReduce(a, (acc, v) => acc + v, 0)\` for summing.
- **arrayReplace(a, ...)**: Replaces elements in array \`a\` with provided arguments, starting from index 0.
- **arrayReplaceAt(a, offset, ...)**: Replaces elements in array \`a\` from \`offset\` with provided arguments.
- **arraySort(a)**: Sorts array \`a\` in ascending order.
- **arraySortBy(a, fn)**: Sorts array \`a\` using comparison function \`fn(v1, v2)\`.
- **arraySum(a)**: Calculates the sum of elements in array \`a\`.

### Waveform Functions - Overview

- **time(interval)**: Generates a sawtooth waveform looping approximately every 65.536 * \`interval\` seconds.
- **wave(v)**: Converts sawtooth waveform \`v\` (0.0 to 1.0) to a sinusoidal waveform.
- **square(v, duty)**: Creates a square wave from sawtooth waveform \`v\` using \`duty\` cycle (0.0 to 1.0).
- **triangle(v)**: Converts sawtooth waveform \`v\` to a triangle waveform.
- **mix(low, high, weight)**: Linear interpolation between \`low\` and \`high\` based on \`weight\`.
- **smoothstep(low, high, v)**: Smooth interpolation based on \`v\` crossing between \`low\` and \`high\`.
- **bezierQuadratic(t, p0, p1, p2)**: Quadratic bezier curve for given points at \`t\`.
- **bezierCubic(t, p0, p1, p2, p3)**: Cubic bezier curve for given points at \`t\`.
### Waveform Functions (Continued)

- **perlin(x, y, z, seed)**: Generates 3D Perlin noise. It produces different random results for every integer value, with smooth transitions. Values repeat every 256 or as set by \`setPerlinWrap()\`, enabling seamless wrapping.
    
- **perlinFbm(x, y, z, lacunarity, gain, octaves)**: Creates 3D fractal Perlin noise (fractal Brownian Motion). Values repeat as per \`setPerlinWrap()\`. \`lacunarity\` controls octave distance (set to 2 or integer for wrapping), \`gain\` controls octave strength (0.5-0.8), and \`octaves\` determines the number of layers.
    
- **perlinRidge(x, y, z, lacunarity, gain, offset, octaves)**: Produces 3D fractal ridged Perlin noise. Similar to \`perlinFbm\` but uses \`offset\` for ridge inversion. Suitable values for \`offset\` are around 1.0.
    
- **perlinTurbulence(x, y, z, lacunarity, gain, octaves)**: Generates 3D fractal turbulent Perlin noise. The parameters are similar to \`perlinFbm\`.
    
- **setPerlinWrap(x, y, z)**: Sets wrapping intervals for Perlin functions between 2 and 256. Useful for creating seamlessly repeating textures.
    
### Pixel / Color Functions

- **hsv(hue, saturation, value)**: Sets the current pixel color in HSV color space. \`hue\` wraps between 0.0 and 1.0. Supports 24-bit color and extra brightness control for compatible LEDs.
    
- **hsv24(hue, saturation, value)**: Similar to \`hsv\` but uses only 24-bit color. Suitable for LEDs that don't support extra brightness resolution.
    
- **rgb(red, green, blue)**: Sets the current pixel color using RGB values ranging from 0.0 to 1.0.
    
- **setPalette(array)**: Defines a color palette from an array of positions and RGB values. Example: Fading from black to magenta to cyan.
    
- **paint(value, [brightness = 1])**: Colors the current pixel based on \`value\`'s position in the palette. Optional \`brightness\` parameter adjusts the intensity.
    

### Coordinate Transformation Functions

- **resetTransform()**: Resets all coordinate transformations to default.
    
- **transform(m11, m21, m31, m41, m12, m22, m32, m42, m13, m23, m33, m43, m14, m24, m34, m44)**: Applies a custom 4x4 matrix transformation to the pixel coordinates.
    
- **translate(x, y)**: Translates pixel coordinates in 2D space.
    
- **scale(x, y)**: Scales pixel coordinates in 2D, affecting pixel density.
    
- **rotate(angleRads)**: Rotates pixel coordinates in 2D space around the Z-axis.
    
- **translate3D(x, y, z)**: Translates pixel coordinates in 3D space.
    
- **scale3D(x, y, z)**: Scales pixel coordinates in 3D, affecting pixel density.
    
- **rotateX(angleRads)**: Rotates pixel coordinates around the X-axis in 3D space.
    
- **rotateY(angleRads)**: Rotates pixel coordinates around the Y-axis in 3D space.
    
- **rotateZ(angleRads)**: Rotates pixel coordinates around the Z-axis in 3D space.
    

### Pixel Map Functions

- **pixelMapDimensions()**: Returns the number of dimensions in the pixel map (2 for 2D, 0 for no map).
    
- **mapPixels(fn)**: Iterates over pixels with their map coordinates. The function \`fn\` is called with arguments (\`index\`, \`x\`, \`y\`, \`z\`). For 2D maps, \`z\` is 0, and without a map, \`x\` is \`index/pixelCount\`, \`y\` and \`z\` are 0.
    

### Clock / Time Functions

- **clockYear()**: Returns the current year.
    
- **clockMonth()**: Returns the current month.
    
- **clockDay()**: Returns the current day.
    
- **clockHour()**: Returns the current hour in 24-hour format.
    
- **clockMinute()**: Returns the current minute.
    
- **clockSecond()**: Returns the current second.
    
- **clockWeekday()**: Returns the current weekday (Sunday = 1, Monday = 2, etc.).
    

### Sensor Expansion Board

The sensor expansion board adds functionalities like a microphone for audio processing

- **frequencyData**: 32-element array with frequency magnitude data (12.5-10kHz range).
- **energyAverage**: Measures total audio volume.
- **maxFrequency** and **maxFrequencyMagnitude**: Detects the strongest tones with about 39Hz resolution.

These features are accessed using the \`export var\` syntax, with optional defaults if the board is not connected.
`

// Request a first draft of the code to run.
const initialPrompt = userGoal => `
# Task

Hey GPT4 I am programming a Pixelblaze v3 with your help today! 

The mapper is set up in a 22 x 22 matrix 

This is the mapping code 

\`\`\` 
function (pixelCount) { 
	width = 22 
	var map = [] 
	for (i = 0; i < pixelCount; i++) { 
		y = Math.floor(i / width) 
		x = i % width 
		x = y % 2 == 1 ? width - 1 - x : x //zigzag 
		map.push([x, y]) } 
	return map 
} 
\`\`\` 


I have a sensor board so I can use sound inputs. This means that the frequencyData is available 

\`\`\` 
// Sound data
export var frequencyData = array(32); 
\`\`\` 

I wanted to write a pattern that looks like ${userGoal} 

When creating a complex pattern, break it into steps. Always start with something simple and then iterate to make it dynamic and colorful. So if I ask you to make a robot heart that is on fire ... start by drawing a heart, then making it robotic, then animating it. Even though you've done this, in each step please write code that can directly run in the Pixelblaze and I will give you any errors or feedback from the IDE or images of the generated visual pattern. Enclose the code you write in triple backticks. I will be directly copying that code into the compiler and responding with the compiler's feedback.

But today I this task I am asking you to write a pattern that looks like ${userGoal}. Please write code I can directly run in the Pixelblaze and I will give you any errors or feedback from the IDE or images of the generated visual pattern.

Let's go! I have provided the syntax of the language below. It is really similar to Javascript but simplified, and with some special functions and variables for noise and waves etc.

${languageFeaturesAppendix}
`;

// Ask for an amended version of code if a compiler error occurs.
function makeErrorPrompt(code, errorMsg) {
return `
Please debug the following Pixelblaze code, and produce a fixed version.
Output the entire amended code in triple backticks.
Do not output partial code.

Original code:
\`\`\`
${code}
\`\`\`

Error:
\`\`\`
${errorMsg}
\`\`\`

Here is the Pixelblaze language documentation as a reference:

${languageFeaturesAppendix}
`;
}

// Ask if the previous code produces an acceptable result, or attempt to receive actionable feedback on how to improve it.
// Intended to be used by GPT-4 with Vision, accompanied by the output image produced by the code.
//
// Note that this prompt is *not* intended to produce code. This better separates responsibility between models with vision capability and code-generation models.
function makeSuccessPrompt(userGoal, code) {
return `
Please determine if you're happy with the output of the following code by looking at the corresponding image. If you're happy please include the exact string "HAPPY" in the response, otherwise include the string "NOTHAPPY". Do not include "HAPPY" in the response unless you are satisfied with the result. If not, please provide the next specific step for improving this code to make output closer to the request. In all cases, keep it really simple, give the next simple step towards success.

Request: write a Pixelblaze pattern that looks like ${userGoal}

Code:
\`\`\`
${code}
\`\`\`
`;
}

// Follow-up to address feedback identified by the vision prompt, making incremental changes to code that compiles successfully.
function makeIncrementalUpdatePrompt(userGoal, previousCode, feedback) {
return `
You wrote the following code that compiled successfully for a Pixelblaze led controller:

\`\`\`
${previousCode}
\`\`\`

However, it still needs some work. This is the feedback from the visual pattern created:
${feedback}

Please iterate towards creating a pattern that looks like ${userGoal}. Please do only the very next smallest step since you are a junior programmer just learning the platform.

Please write the entire updated program, not just the updated part. It will be passed directly to the compiler as written.

${languageFeaturesAppendix}
`;
}

/* -- UI HELPER CODE -- */

// Sometimes, `getEventListeners` is undefined when accessed directly inside `copyCodeToEditor` or `clearEditor`.
// I don't know why, please tell me if you can figure it out!
// But they work when predefined as constants here.
const editorElement = document.querySelectorAll('#expression .ace_text-input')[0];
const pasteListener = window.getEventListeners(editorElement).paste[0].listener;
const ctrlAListener = window.getEventListeners(editorElement).keydown[0].listener;
const backspaceListener = window.getEventListeners(editorElement).keydown[0].listener;

// Copies code into the editor UI
function copyCodeToEditor(code) {
  const ev = new Event('paste');
  ev.clipboardData = {
    getData: () => {
      return code;
    },
  };

  pasteListener(ev)
}

// Extracts any posted compile error from the UI
function getCompileError() {
  const error_element = document.getElementById('expressionHelp');
  const text = error_element.textContent;
  const okText = 'Looks ok, pattern is live!';
  if (text === okText) {
    return undefined;
  } else {
    return text;
  }
}

// Returns a data URL for the preview image in the UI canvas
function capturePreviewImage() {
  const canvas_element = document.getElementById('editorMappedCanvas');
  const data_url = canvas_element.toDataURL('image/png');

  return data_url;
}

// Clears all code from the editor UI
function clearEditor() {
  // Simulate `Ctrl-A` to select all...
  const selectEvent = new Event('keydown');
  selectEvent.keyCode = 65;
  selectEvent.key = 'a';
  selectEvent.code = 'KeyA';
  selectEvent.ctrlKey = true;

  // And then `Backspace` to delete it
  const backspaceEvent = new Event('keydown');
  backspaceEvent.keyCode = 8;
  backspaceEvent.key = 'Backspace';
  backspaceEvent.code = 'Backspace';

  ctrlAListener(selectEvent);
  backspaceListener(backspaceEvent);
}

/* -- PROMPT HELPER CODE -- */

// Return the last triple-backtick-surrounded codeblock in the provided text
function extractBackticksContent(text) {
  // Regular expression to match all content between triple backticks
  // The optional word following the opening triple backticks is captured but not used
  const pattern = /```(?:\w+)?(.*?)```/sg;
  
  // Extract and return the last matched group
  const matches = [...text.matchAll(pattern)];
  return matches.map(match => match[1].trim()).slice(-1)[0];
}

// Generate an initial code draft
async function getInitialCodeSuggestion(userGoal) {
  return extractBackticksContent((await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENAI_SECRET_KEY}`
      },
      body: JSON.stringify({
          model: 'gpt-4',
          messages: [{ role: 'user', content: initialPrompt(userGoal) }],
          temperature: 0.7,
      })
  })
  .then(response => response.json())
  .catch(error => console.error('Error:', error)))
  .choices[0].message.content);
}

// Use GPT-4 to suggest updated code in response to feedback produced by examining the output of a previous iteration
async function getUpdateCodeSuggestion(userGoal, previousCode, feedback) {
  return extractBackticksContent((await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENAI_SECRET_KEY}`
      },
      body: JSON.stringify({
          model: 'gpt-4',
          messages: [{
            role: 'user',
            content: makeIncrementalUpdatePrompt(userGoal, previousCode, feedback),
          }],
          temperature: 0.7,
      })
  })
  .then(response => response.json())
  .catch(error => console.error('Error:', error)))
  .choices[0].message.content);
}

// Use GPT-4 with Vision to get feedback on previously written code that has produced an image preview
async function getImageResponse(userGoal, code, imageB64) {
  const response = (await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${OPENAI_SECRET_KEY}`
    },
    body: JSON.stringify({
      model: 'gpt-4-vision-preview',
      max_tokens: 1500, // gpt-4-vision-preview uses a very low max token count by default
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: makeSuccessPrompt(userGoal, code),
            },
            {
              type: 'image_url',
              image_url: {
                url: imageB64,
              }
            }
          ],
        }
      ]
    })
  })
  .then(response => response.json())
  .catch(error => console.error('Error:', error)))
    .choices[0].message.content;
  if (response.indexOf('HAPPY') >= 0 && response.indexOf('NOTHAPPY') < 0) {
    return undefined;
  } else {
    return response;
  }
}

// Use GPT-4 to suggest updated code in response to a compiler error
async function getErrorResponse(code, errorMsg) {
  return extractBackticksContent((await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENAI_SECRET_KEY}`
      },
      body: JSON.stringify({
          model: 'gpt-4',
          messages: [{ "role": "user", "content": makeErrorPrompt(code, errorMsg) }],
          temperature: 0.7,
      })
  })
  .then(response => response.json())
  .catch(error => console.error('Error:', error)))
  .choices[0].message.content);
}

/* -- MAIN LOGIC -- */

{
  clearEditor();
  copyCodeToEditor('/* Please wait, OpenAI is producing a response... */');
  let codeToRun = await getInitialCodeSuggestion(userGoal);

  outerLoop: while (true) {
    console.log('RUNNING AGAIN');
    if (codeToRun === undefined) {
      console.log('OpenAI is finally happy with the output.');
      break;
    }
    if (codeToRun === '') {
      console.log('code was empty for some reason.');
      break;
    }
    clearEditor();
    copyCodeToEditor(codeToRun);
    await new Promise(resolve => setTimeout(resolve, 1000));
    const error = getCompileError();
    if (error) {
      console.log('ERROR');
      codeToRun = await getErrorResponse(codeToRun, error);
    } else {
      console.log('SUCCESS');
      let message = await getImageResponse(userGoal, codeToRun, capturePreviewImage());
      let currentDepth = 0;
      // This could probably be condensed into one loop, but... hackathons :p
      while (currentDepth < 5) {
        if (message === undefined) {
          console.log('GPT is satisfied!');
          break outerLoop;
        }
        codeToRun = await getUpdateCodeSuggestion(userGoal, codeToRun, message);
        clearEditor();
        copyCodeToEditor(codeToRun);
        await new Promise(resolve => setTimeout(resolve, 1000));
        const error = getCompileError();
        if (error) {
          console.log('ERROR (inner loop)');
          codeToRun = await getErrorResponse(codeToRun, error);
        } else {
          console.log('SUCCESS (inner loop)');
          message = await getImageResponse(userGoal, codeToRun, capturePreviewImage());
          if (message === undefined) {
            console.log('GPT is satisfied! (inner loop)');
            break outerLoop;
          }
        }
        currentDepth += 1;
      }
    }
  }
}
